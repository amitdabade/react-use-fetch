import e,{useState as r,createContext as t,useReducer as a,useContext as n,useRef as c,useEffect as l}from"react";const s=(e,r)=>{switch(r.type){case"UPDATE_STATUS":return{...e,fetching:r.payload.fetching,status:r.payload.status};case"UPDATE_ON_SUCCESS":case"UPDATE_ON_ERROR":return{...e,data:r.payload.data,error:r.payload.error,fetching:r.payload.fetching,status:r.payload.status,request:r.payload.request,response:r.payload.response};default:return{...e}}},u={data:null,error:null,fetching:!1,status:"idle",request:null,response:null},o={delay:0,retry:0,refetchInterval:0,refetch:1/0,responseType:"text"},f=t(o);function y(t){const{config:a}=t,[n,c]=r({...o,...a});return e.createElement(f.Provider,{value:{...n,updateGlobalConfig:e=>{c(e)}}},t.children)}const d=(e,r)=>{const[t,o]=a(s,u),y=n(f),d=c({refetch:r?.refetch??y.refetch,retry:r?.retry??y.retry,responseType:r?.responseType??y.responseType,delay:r?.delay??y.delay,refetchInterval:r?.refetchInterval??y.refetchInterval}),p=c(0),i=c(0),h=c(null),T=c(null);let g=c(null);l((()=>()=>{clearTimeout(h.current),clearInterval(T.current)}),[]);const v=async e=>{let r=null,t=null,a=null;o({type:"UPDATE_STATUS",payload:{fetching:!0,status:"fetching"}}),g.current=new AbortController;try{r=new Request(e.url,{signal:g.current.signal,...e}),t=await fetch(r),a=await((e,r)=>{switch(r){case"json":return e.json();case"text":default:return e.text();case"blob":return e.blob();case"formData":return e.formData();case"arrayBuffer":return e.arrayBuffer()}})(t,d.current.responseType);try{a=JSON.parse(a)}catch(e){}o((e=>({type:"UPDATE_ON_SUCCESS",payload:e}))({fetching:!1,status:"success",data:a,error:null,request:r,response:t}))}catch(a){if(i.current===d.current.retry)return void o((e=>({type:"UPDATE_ON_ERROR",payload:e}))({fetching:!1,status:a?.message.includes("aborted")?"abort":"error",data:null,error:a,request:r,response:t}));b(e,d),i.current++}},b=(e,r)=>{if(0!==r.current.refetchInterval||r.current.refetch!==1/0)return v(e),void(T.current=setInterval((()=>{p.current!==r.current.refetch?(v(e),p.current++):clearInterval(T.current)}),r.current.refetchInterval));r.current.delay?h.current=setTimeout((()=>{v(e)}),r.current.delay):v(e)};return{...t,fetch:b.bind(void 0,e,d),abort:()=>{g.current.abort()}}};export{y as UseFetchProvider,d as useFetch};
